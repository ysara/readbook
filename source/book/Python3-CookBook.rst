Python3 CookBook
==================

数据结构和算法
----------------

1.3 保留最后N个元素
~~~~~~~~~~~~~~~~~~~~

在队列两端插入或删除元素时间复杂度都是 O(1) ，而在列表的开头插入或删除元素的时间复杂度为 O(N) 。

1.4 查找最大或最小的N个元素
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: Python

   heapq模块有两个函数：``nlargest()`` 和 ``nsmallest()``

如果你想在一个集合中查找最小或最大的N个元素，并且N小于集合元素数量，那么这些函数提供了很好的性能。 因为在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中：

堆数据结构最重要的特征是 ``heap[0]`` 永远是最小的元素。并且剩余的元素可以很容易的通过调用 ``heapq.heappop()`` 方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素(这种操作时间复杂度仅仅是``O(log N)``，N是堆大小)。 

当要查找的元素个数相对比较小的时候，函数 ``nlargest()`` 和 ``nsmallest()`` 是很合适的。 如果你仅仅想查找唯一的最小或最大(N=1)的元素的话，那么使用 ``min()`` 和 ``max()`` 函数会更快些。 类似的，如果N的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 ( ``sorted(items)[:N]`` 或者是 ``sorted(items)[-N:]`` )。 需要在正确场合使用函数 ``nlargest()`` 和 ``nsmallest()`` 才能发挥它们的优势 (如果N快接近集合大小了，那么使用排序操作会更好些)。

1.6 字典中的键映射多个值
~~~~~~~~~~~~~~~~~~~~~~

一般来讲，创建一个多值映射字典是很简单的。但是，如果你选择自己实现的话，那么对于值的初始化可能会有点麻烦， 你可能会像下面这样来实现：

.. code-block:: python

    d = {}
    for key, value in pairs:
        if key not in d:
            d[key] = []
        d[key].append(value)

如果使用 defaultdict 的话代码就更加简洁了：

.. code-block:: python

    d = defaultdict(list)
    for key, value in pairs:
        d[key].append(value)
